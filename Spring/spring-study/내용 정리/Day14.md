할인 정책 변경

- 기존의 OrderServiceImple은 DiscountPolicy를 의존하고 있었다.
그렇지만 실제로 확인해보면 DiscountPolicy(인터페이스)와 FixDiscountPolicy(구현체)를 동시에 의존하는 꼴이었다.
DiscountPolicy discountpolicy = new FixDiscountPolicy();
=> DIP위반
- 클라이언트가 인터페이스만 의존하도록 변경

AppConfig
 - App전체의 동작 방식을 구성하기 위해 구현객체 생성 / 연결을 하는 책임을 가진 별도의 설정 클래스
 - 구현 객체를 생성하고, 연결하는 책임(역할)을 갖게 됨

AppConfig reFactoring
 - 열할이 드러나게 구성하는게 좋다.
 - 중복도 함께 최소화 된다.
 Ex. 구현체를 교체할때마다 new MemoryMemberRepository() 모두를 수정할 필요없이. AppConfig의 getMemberRepository의 return값만 변경해주면된다.
 - 구성영역(AppConfig)와 실행영역을 구분함

좋은 객체지향의 5가지 원칙
# SRP. 단일책임의 원칙
- 한클래스는 하나의 책임만 가져야한다.
1. 단일 책임원칙을 따르며 관심사를 분리함
2. 구현객체 생성 / 연결책임 생성으로 분리
3. 클라이언트 객체는 실행 책임만을 담당할 수 있게됨

# DIP. 의존관계 역전원칙
- 프로그래머는 추상화에만 의존을 해야지, 구체화도 의존해서는 안된다.(의존성 주입은 이 원칙을 따르는 방법중 하나이다.)
- 기존의 문제점 : 새로운 할인 정책을 적용하려 하니, 클라이언트의 코드도 수정해야 했음.
1. AppConfig라는 객체가 클라이언트 코드 대신 인스턴스를 생성하여 클라이언트 코드에 의존관계를 주입함

#OCP. 개방폐쇄의 원칙
- 소프트웨어 요소는 확장에는 열려있지만, 변경에는 닫혀야한다.
1. 인스턴스를 교체할 때 AppConfig가 의존관계를 주입해주므로 클라이언트 코드는 변경하지 않아도 됨
- 소프트웨어 요소를 새롭게 확장해도, 사용 영역의 변경은 닫혀있다.

